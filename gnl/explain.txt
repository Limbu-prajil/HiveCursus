
	At first, our file is opened and assigned a file stream which is usually 3 and initialised to int fd.
Then we enter the while loop which loops until all the lines from the file stream is read. Inside of the
while loop we check the condition and inside of the condition we have getnextline. we call it with fd.
The getnextline function receives the fd and starts to extract each line from fd. we first create a static structure variable list which points to t_list and the variable is assigned NULL.

	we check then if the fd is valid, buffer size is valid, and that the read function is working as expected. If it fails then we return NULL to the main() and the while loop exits because the condition is false as NULL==NULL then the fd is closed. if the fd, buffer size and read works as intended, we move to create list.

	And in createlist() we pass address of original struct list which is address of the  original structure variable and it contains NULL as a value at first and fd as the assigned file stream. when we move to createlist() we receive the address of the structure variable list as **list and inside of createlist list contains address of original struct list and fd as fd. inside we have while loop which has a condition to check if a newline is found. and for that we use foundnewline(). we call foundnewline with *list(value inside of the original struct variable) where list=address of the original struct variable and *list is the value(NULL) associated with the original struct list variable. 

	The foundnewline receives *list as new struct variable list and new list has the value(NULL) in it meaning just using list, list becomes *list(value of the original struct variable which now is NULL). First it checks if list which now is the value (NULL) is NULL(empty list) or not, which in our case it is NULL and returns 0.

	we return to createlist while loop and the condition is true, we move inside the loop and start to create(populate) linked list. we first allocate memory for the buffer, if the allocation of the buffer is failed then we return to getnextline and check of if the list is NULL or not, in our case it is and we return NULL to main(), when inside of main the while loop fails and then the loop exits and then the fd is closed. If memory allocation is done for buffer,then we read from the fd the exact buffer_size and put the read bytes into buffer. we assign the number of read bytes to charread int. we check if the charread is <= 0 to check if read() worked or not and to check if EOF has reached. In our case it should work hoping read() works and our fd has not reached it EOF. If in case, it fails, then we free the buffer we created with malloc and return with nothing to getnextline and then return NULL to main() because the list is empty still, just to close the fd. since malloc and read works, we null terminate the buffer. then we move to appending our orignal struct list. we pass to append() list which is address of the original struct list and just created buffer.

	In append(), we receive those two arguments as double pointer **list where inside of the function, list equals to address of the original struct list and char pointer buf which is buf we just created containing the bytes read from fd. Here we declare newnode and lastnode struct variables. lastnode is used to hold the last node of our list, if our list contains somehow. the function findlastnode() is passed *list which is the value(now NULL) of the original struct list. Now the findlastnode receives our *list as *list where inside of findlastnode() list=NULL now. in findlastnode we first check if list==NULL, condition passes then we return NULL to append(). when in append(), we assign lastnode as NULL and the we initialise the newnode with malloced memory. we check if mem alloc fails, if it fails we return nothing to createlist indicating that the creation of the list failed, which in turn starts the while loop with foundnewline(*list= still NULL). then while condition is true because foundnewline returns 0 as the list is still NULL and buffer allocation fails then we return nothing to getnextline and then return NULL to main() and then close fd. In our case the alloc wont fail, inside of append() we move to check if lastnode is NULL which in our case it is and then we assign newly created newnode into *list(value of original struct list) meaning the value of original struct list is now the newnode. Moving on we assign strbuf of newnode with buffer we received as parameter and assign next pointer as NULL.

	Now we have our original list value has changed due to append(). Returning from append() and still in createlist() where list is the address of original struct list which means that *list=newnode we just created and contains strbuf and next pointer. Now after the first while loop in createlist the *list has changed and in the second loop we call foundnewline with *list to check if the condition is true or not. As we call the foundnewline inside of the while loop's condition, we pass the newnode=*list to foundnewline and it receives the newnode as *list where in list=newnode created.

	When inside of foundnewline, we find that list is not NULL, then we enter into while loop which first checks if list is true or not, in our case list is not empty and we enter into nested while loop to check if we find the \n or not. We check for characters until the strbuf ends and just the size of the BUFFER_SIZE. if we find \n while looping the newnode strbuf then we return 1 or else if we don't find \n we come out of loop and we assign value of list->next which is NULL in our case, to list itself, basically trying to move to the next node or exit from the outer while loop and return 0 from the foundnewline to createlist() WITHOUT CHANGING THE ORIGINAL LIST.

	After we dont find the \n, the createlist function receives the return value 0 and find the condition is true, so the second while loop is executed. During the execution of second while loop, new buffer is allocated, buffer is checked, with read() fd is read with exact BUFFER_size amount and put into buffer and initialise it to charread. charread is checked if it is <= 0 basically checking that if there is error reading fd or EOF in fd is reached. If any of these are true, then the buffer is freed and nothing is returned from createlist and then the execution is progressed as normal into getnextline, since our list is not empty, getline is called with list which in our case is the newnode we created before. But in our case, charread is more than 0 and we move ahead to put last index of buffer as nul terminator and then we call append() again with the address of the original struct list and buffer created with malloc. Append() receives the address of the original list and it is put into **list(where in list=address of original struct list and *list=value inside of the address of original struct list) and also newly created buffer is received. Two new struct variables are declared. Findlastnode is called with the value of our original list which in our case now is a single newnode created before. The findlastnode receives the value of original struct list and finds the last node. First it checks whether the value of address(list in findlastnode) is NULL or not. It is not, so we enter into while loop and first we check if the value of the next pointer of the value of address of original list is NULL or not. In our case it is, meaning that it is the only node/ first node/ head node in our list, then we exit the while loop and we return the value of the original list meaning the newnode itself. Which means that lastnode from append() receives the last node(in our case the only node) from the original struct list. And newnode is allocated memory and checked if the memory allocation has failed. Then, lastnode is checked if it is NULL or not, now it is not NULL and we move into else block and assign just created newnode into the next pointer of our last node of our original struct list. Meaning the newnode has become the last node of the original struct list and new buffer is added to the strbuf of newnode and NULL to the next pointer.

	Now, we move into the third while loop inside of createlist. Since original struct list has been changed and contains two nodes now. And the second node contains the \n, we know that the return value of the foundnewline will be true that is 1. We call foundnewline with the value of the original list, and foundnewline receives it as another list variable and we check if it is NULL or not, it is not, so we check if the list=value of original list is NULL or not, it is not so we enter into while loop and start to traverse the strbuf of nodes of the original list. Now since we have two nodes in linked list, just using the name of the linked list is the same as using the first node of the linked list. We check the whole strbuf of the first node and we do not find the \n character. We move to the next node by assigning firstnode's next pointer to itself, so after that the list variable contains the value of the second node and it is also not NULL so we enter the second loop and check every character of the second node's strbuf and try to find \n character in it. In our case we find the \n character.

	Suppose we find the \n character in our second node of our original list, we return 1 from foundnewline to createlist and the while loop inside of createlist exits too and list creation is put on halt. The execution exits the createlist function and then enters getnextline again and checks if the value of original list is NULL or not, in our case, it is not and contains two nodes. Now we use getline() to get a line from the original linked list and then initialise the returned line into nextline.

	Now getline is called with the value inside of original list which means the two nodes created before. The list(value of list) passed to getline is received as *list another struct list variable, in where list=value of the original list. strlen for calculating the total length of our line until \n is declared. nextstr for copying our line and sending the line to getnextline is created. We check if list is empty or not, it is not but if it is, then we return NULL into nextline of getnextline, then return NULL to main() just to close the fd. Since out list is not empty, we call lentonewline with the value of original list. The function lentonewline receives as a parameter the value inside of the new struct list variable.
	
	When inside of lentonewline, we check if the list(the value of original list) is NULL or not. It is not, but if it is then we return 0 to strlen inside of getline. ?????  Since list is not NULL, we enter into while loop and return the len until \n from the two nodes. Say we have \n at the 5th index, we have lens 10 already because of first node, and when we reach the 5th index of second node, the length of added 6 + 10, then 16 is returned to strlen of getline. Nextstr is then malloced 16 + 1 to add \0 in the end. Allocation is checked. Copystr is passed list and nextstr. list as the value of original list which is two nodes linked list. and nextstr as just allocated memory.
	
	The copystr receives the values, list=the two node linked list as *list and nextstr as *str. We check if list is NULL and if it is then we return nothing, eventually returning malloced memory only with garbage values. To copy nextstr into str, we iterate through the linked list nodes and for the first node, we put every indices of the strbuf of first node intoo indices of str(at the end of first node, value of k is 10). and when we move into the second node, then we check the \n and until 4th index, we copy until 4th index of strbuf of list into until 4th index of str(k=15) and then when we find \n at the 5th index, we assign 15th index of str as \n and 16th index of str as \0. then we return nothing making the nextstr=str[16]. Then we return nextstr from getline to nextline of getnextline.
	
	Moving on, we call polishlist with the address of the original list. we receive the address of original list and a double pointer **list in polishlist. In where list equals the address of the original list and *list equals the value inside of the address of the original list. We declare lastnode and cleannode, buf for storing any extra characters remaining after the \n. Memory for buf is allocated buffersize + 1 just to be sure maximum number of bytes of memory is allocated. cleannode is malloced with the size of struct list to accomodate our structure format. Memory allocations are checked. Again, to find the lastnode of our linked list, *list which is the two node linked list, is passed into findlastnode. The function findlastnode returns the last node and assigns it to lastnode of polistlist. then we iterate through the strbuf of lastnode, iterating and incrementing the value of i until we find \n. In our case we find the \n at the index 4 of strbuf of lastnode, i retains the value as 4 and we move to copy the characters after the \n. With the help of while loop, we check if start and (start + 1) index of strbuf of lastnode exists. if both exists which in our case it does, then we copy the (start + 1) indexed char is copied into buf. At the last index of the strbuf of lastnode(which means the last index of the strbuf is already copied into buf), the start + 1 is \0 and the while loop exits, then we nul terminate the buf with the cound of K(which is the last index of buf). Then we assign the jus copied buf into the strbuf of cleannode and NULL is assigned to next pointer of cleannode. Finally we call the dealloc with list which is the address of the original list, cleannode which is a newly made struct variable, and buf which we copied the remaining characters from the lastnode of original list.
	
	The dealloc function receives the address of original list as **list where list=address itself and *list=linked list, receives cleannode as *cleannode where cleannode=new node created with buf and NULL, also receives the buf which has the copied characters from the lastnde of our original linkedlist. First a tmp struct variable is created. Empty list or not checked. then we iterate through the linked list(*list) and free each node. the first node of linked list is checked(*list), it is true and we enter in while loop, we first assign next pointer of first head node into tmp meaning tmp holds the pointer of the second node,then we free the strbuf of the firstnode and then the firstnode itself. then the tmp is assigned into *list(now has become the firstnode) and the while loop continues until the *list becomes NULL in other words all the nodes are cleaned and freed and the last node has reached. Then since the linked list is freed, we initialise or reset the list with NULL, making the list variable ready for initialisation. Now finally we check if the first index of the strbuf of cleannode is true or not, checking if the cleannode's buffer is empty or not. In our case it is true, so we assign the cleannode into reset *list so that it can be retained when the getnextline is called again.if we find the cleannode buffer is empty meaning the \n is at the last index of lastnode of originall linked list, then we free the buffer and free the cleannode as well.
	
	Then we return the nextline into main() and the while loop validates the condition as true and prints the nextline and then frees the line itself. then again iterates the while loop to call getnextline with the same fd. As the getnextline() is called, the struct variable list retains the value from the previous function call and contains cleannode now.

