
	At first, our file is opened and assigned a file stream which is usually 3 and initialised to int fd.
Then we enter the while loop which loops until all the lines from the file stream is read. Inside of the
while loop we check the condition and inside of the condition we have getnextline. we call it with fd.
The getnextline function receives the fd and starts to extract each line from fd. we first create a static structure variable list which points to t_list and the variable is assigned NULL.

	we check then if the fd is valid, buffer size is valid, and that the read function is working as expected. If it fails then we return NULL to the main() and the while loop exits because the condition is false as NULL==NULL then the fd is closed. if the fd, buffer size and read works as intended, we move to create list.

	And in createlist() we pass address of list which is address of the structure variable and it contains NULL as a value and fd as the assigned file stream. when we move to createlist() we receive the address of the structure variable list as **list and the **list contains address of struct list and fd as fd. inside of the createlist we have while loop which has a condition to check if a newline is found. and for that we use foundnewline(). we call foundnewline with *list, list=address of the variable itself and *list is the value(NULL) associated with the original struct list variable. 

	The foundnewline receives *list as new variable struct variable list and new list has the value(NULL) in it. first it checks if list which now is the value (NULL) if NULL or not, which in our case it is NULL and returns 0.

	we return to createlist while loop and the condition is true, we move inside the loop and start to create linked list. we first allocate memory for the buffer, if the allocation of the buffer is failed then we return to getnextline and check of if the list is NULL or not, in our case it is and we return NULL to main(), when inside of main the while loop passes and then the loop exits and then the fd is closed. If memmory allocation is done,then we read from the fd the exact buffer size and put the read bytes into buffer. we assign the number of read bytes to charread int. we check if the charread is <= 0 to check if read() worked or not. In our case it should work. If in case, it fails, then we free the buffer we created with malloc and return with mothing to getnextline and then return NULL to main() just to close the fd. since malloc and read worked, we null terminate the buffer. then we move to appending our list. we pass to append() list=address of the original struct list and just created buf.

	In append(), we receive those arguments as double pointer **list where list=address of the original struct and char pointer buf which is buf we just created. Here we declare newnode and lastnode struct variables. lastnode is used to calculate the last node of our list. the function findlastnode is passed *list which is the value(NULL) of the original struct list. Now the findlastnode receives our *list as *list. where in list=NULL in our case. in findlastnode we first check if list==NULL, condition passes then we return NULL to append(). when in append(), we assign lastnode as NULL and the we initialise the newnode with malloced memory. we check if mem alloc fails, if it fails we return nothing to createlist indicating that the creation of the list failed, which in turn starts the while loop with *list=NULL. then while condition is true and buffer allocation fails then we return nothing to getnextline and then return NULL to main() and then close fd. In our case the alloc wont fail, we move to check if lastnode is NULL and in our case our lastnode is NULL and then we assign newly created newnode as the value of *list= value of original struct list. Moving on we assign strbuf of newnode with buffer we received as parameters and assign next pointer as NULL.

	Now we have our *list value has changed due to append(). Where *list=newnode we just created and contains strbuf and next pointer. Now after the first while loop in creaelist the *list has changed and in the second loop we call foundnewline to check if the condition is true or not. As we call the foundnewline inside of the while loop's condition, we pass the newnode to foundnewline and it receives the newnode as *list where list=newnode itself. When inside of foundnewline, we find that list is not NULL, then we enter into while loop which first checks if list is NULL or not, in our case list is not empty and we enter into nested while loop to check if we find the \n or not. We check for characters just the size of the BUFFER_SIZE. if we find \n while looping the newnode strbuf then we return 1 or else if we don't find \n we come out of loop and we assign value of list->next which is NULL in our case, to list itself, basically trying to move to the next node or exit from the outer while loop and return 0 from the foundnewline to createlist().

	The createlist function receives the return value and find the condition is true, so the second while loop is executed. During the execution of second while loop, new buffer is allocated, buffer is checked, with read() fd is read with exact BUFFER_size amount and put into buffer and initialise it to charread. charread is checked if it is <= 0 basically checking that if there is error reading fd or EOF in fd is reached. If any of these are true, then the buffer is freed and nothing is returned from createlist and then the execution is progressed as normal and getline is called with list which in our case is the newnode we created before. But in our case, charread is more than 0 and we move ahead to put last index of buffer as nul terminator and then we call append again with the address of the original struct list and buffer created. Append() receives the address of the original list and put into list and also newly created buffer is received. Two new struct variables are declared. Findlastnode is called with the value of our original list which in our case now is a single node created before. The findlastnode receives the value of original struct list and finds the last node. First it checks whether the value is NULL or not. It is not, so we enter into while loop and first we check if the value of the next pointer is NULL or not. In our case it is, meaning that it is the only node in our list, the we exit the while loop and we return the value of the original list. Which means that lastnode from append() receives the last node from the original struct list. And newnode is allocated memory and checked if the memory allocation has failed. Then, lastnode is checked if it is NULL or not, now it is not NULL and we move into else block and assign just created newnode into the next node of our last node in our original struct list. Meaning the newnode has become a the last node of the original struct list and new buffer is added to the strbuf of newnode and NULL to the next pointer.

	Now, we move into the third while loop inside of createlist. Since original struct list has been changed and contains two nodes now. And the second node contains the \n, we know that the return value of the foundnewline will be true that is 1. We call foundnewline with the value of the original list, and foundnewline receives it as another list variable and we check if it is NULL or not, it is not, so we check if the list=value of original list is NULL or not, it is not so we enter into while loop and start to traverse the nodes of the original list. Now since we have two nodes in linked list, just using the name of the whole value of the linked list is the same as using the first node of the linked list. We check the whole strbuf of the first node and we do not find the \n character. We move to the next node with assigning firstnode's next pointer to itself, so after that the list variable contains the value of the second node and it is also not NULL so we enter the second loop and check every character of the second nodes strbuf and try to find \n character in it. In our case we find the \n character.

	Suppose we find the \n character in our second node of our original list, we return 1 form foundnewline to createlist and the while loop exits and list creation is put on halt. The execution exits the createlist function and then enters getnextline again and checks if the value if original list is NULL or not, in our case, it is not and contains two nodes. Now we use getline function to get a line from the original linked list and then initialise the returned line into nextline.
