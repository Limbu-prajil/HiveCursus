At first, our file is opened and assigned a file stream which is usually 3 and initialised to int fd.
Then we enter the while loop which loops until all the lines from the file stream is read. Inside of the
while loop we check the condition and inside of the condition we have getnextline. we call it with fd.
The getnextline function receives the fd and starts to extract each line from fd. we first create a static structure variable list which points to t_list and the variable is assigned NULL.

we check then if the fd is valid, buffer size is valid, and that the read function is working as expected. If it fails then we return NULL to the main() and the while loop exits because the condition is false as NULL==NULL then the fd is closed. if the fd, buffer size and read works as intended, we move to create list.

And in createlist() we pass address of list which is address of the structure variable and it contains NULL as a value and fd as the assigned file stream. when we move to createlist() we receive the address of the structure variable list as **list and the **list contains address of struct list and fd as fd. inside of the createlist we have while loop which has a condition to check if a newline is found. and for that we use foundnewline(). we call foundnewline with *list, list=address of the variable itself and *list is the value(NULL) associated with the original struct list variable. 

the foundnewline receives *list as new variable struct variable list and new list has the value(NULL) in it. first it checks if list which now is the value (NULL) if NULL or not, which in our case it is NULL and returns 0.

we return to createlist while loop and the condition is true, we move inside the loop and start to create linked list. we first allocate memory for the buffer, if the allocation of the buffer is failed then we return to getnextline and check of if the list is NULL or not, in our case it is and we return NULL to main(), when inside of main the while loop passes and then the loop exits and then the fd is closed. If memmory allocation is done,then we read from the fd the exact buffer size and put the read bytes into buffer. we assign the number of read bytes to charread int. we check if the charread is <= 0 to check if read() worked or not. In our case it should work. If in case, it fails, then we free the buffer we created with malloc and return with mothing to getnextline and then return NULL to main() just to close the fd. since malloc and read worked, we null terminate the buffer. then we move to appending our list. we pass to append() list=address of the original struct list and just created buf.

In append(), we receive those arguments as double pointer **list where list=address of the original struct and char pointer buf which is buf we just created. Here we declare newnode and lastnode struct variables. lastnode is used to calculate the last node of our list. the function findlastnode is passed *list which is the value(NULL) of the original struct list. Now the findlastnode receives our *list as *list. where in list=NULL in our case. in findlastnode we first check if list==NULL, condition passes then we return NULL to append(). when in append(), we assign lastnode as NULL and the we initialise the newnode with malloced memory. we check if mem alloc fails, if it fails we return nothing to createlist indicating that the creation of the list failed, which in turn starts the while loop with *list=NULL. then while condition is true and buffer allocation fails then we return nothing to getnextline and then return NULL to main() and then close fd. In our case the alloc wont fail, we move to check if lastnode is NULL and in our case our lastnode is NULL and then we assign newly created newnode as the value of *list= value of original struct list. Moving on we assign strbuf of newnode with buffer we received as parameters and assign next pointer as NULL.

Now we have our *list value has changed due to append(). Where *list=newnode we just created and contains strbuf and next pointer. Now after the first while loop in creaelist the *list has changed and in the second loop we call foundnewline to check if the condition is true or not. As we call the foundnewline inside of the while loop's condition, we pass the newnode to foundnewline and it receives the newnode as *list where list=newnode itself. When inside of foundnewline, we find that list is not NULL, then we enter into while loop which first checks if list is NULL or not, in our case list is not empty and we enter into nested while loop to check if we find the \n or not. We check for characters just the size of the BUFFER_SIZE. if we find \n while looping the newnode strbuf then we return 1 or else we assign value of list->next which is NULL to list itself. Basically trying to move to the next node or exit from the while loop and return 0 from the foundnewline.
